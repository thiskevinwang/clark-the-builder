// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { addOrganizationTeamMember, cancelBouncerResizeRequest, cancelBranchChangeRequest, cancelDeployRequest, closeDeployRequest, completeErroredDeploy, completeGatedDeployRequest, completeRevert, createBackup, createBouncer, createBranch, createDatabase, createDatabasePostgresCidr, createDeployRequest, createKeyspace, createOauthToken, createOrganizationTeam, createPassword, createQueryPatternsReport, createRole, createServiceToken, createWebhook, createWorkflow, deleteBackup, deleteBouncer, deleteBranch, deleteDatabase, deleteDatabasePostgresCidr, deleteKeyspace, deleteOauthToken, deleteOrganizationTeam, deletePassword, deleteQueryPatternsReport, deleteRole, deleteServiceToken, deleteWebhook, demoteBranch, disableSafeMigrations, enableSafeMigrations, getBackup, getBouncer, getBranch, getBranchChangeRequest, getBranchSchema, getCurrentUser, getDatabase, getDatabasePostgresCidr, getDatabaseThrottler, getDefaultRole, getDeployment, getDeployQueue, getDeployRequest, getDeployRequestThrottler, getInvoice, getInvoiceLineItems, getKeyspace, getKeyspaceRolloutStatus, getKeyspaceVschema, getOauthApplication, getOauthToken, getOrganization, getOrganizationMembership, getOrganizationTeam, getOrganizationTeamMember, getPassword, getQueryPatternsReport, getQueryPatternsReportStatus, getRole, getServiceToken, getWebhook, getWorkflow, lintBranchSchema, listAuditLogs, listBackups, listBouncerResizeRequests, listBouncers, listBranchBouncerResizeRequests, listBranchChangeRequests, listBranches, listClusterSizeSkus, listDatabasePostgresCidrs, listDatabaseRegions, listDatabases, listDeployOperations, listDeployRequestReviews, listDeployRequests, listExtensions, listGeneratedQueryPatternsReports, listInvoices, listKeyspaces, listOauthApplications, listOauthTokens, listOrganizationMembers, listOrganizations, listOrganizationTeamMembers, listOrganizationTeams, listParameters, listPasswords, listPublicRegions, listReadOnlyRegions, listRegionsForOrganization, listRoles, listServiceTokens, listWebhooks, listWorkflows, type Options, promoteBranch, queueDeployRequest, reassignRoleObjects, removeOrganizationMember, removeOrganizationTeamMember, renewPassword, renewRole, resetDefaultRole, resetRole, reviewDeployRequest, skipRevertPeriod, testWebhook, updateAutoApply, updateAutoDeleteBranch, updateBackup, updateBouncerResizeRequest, updateBranch, updateBranchChangeRequest, updateBranchClusterConfig, updateDatabasePostgresCidr, updateDatabaseSettings, updateDatabaseThrottler, updateDeployRequestThrottler, updateKeyspace, updateKeyspaceVschema, updateOrganization, updateOrganizationMembership, updateOrganizationTeam, updatePassword, updateRole, updateWebhook, verifyWorkflow, workflowCancel, workflowComplete, workflowCutover, workflowRetry, workflowReverseCutover, workflowReverseTraffic, workflowSwitchPrimaries, workflowSwitchReplicas } from '../sdk.gen';
import type { AddOrganizationTeamMemberData, AddOrganizationTeamMemberResponse, CancelBouncerResizeRequestData, CancelBouncerResizeRequestResponse, CancelBranchChangeRequestData, CancelBranchChangeRequestResponse, CancelDeployRequestData, CancelDeployRequestResponse, CloseDeployRequestData, CloseDeployRequestResponse, CompleteErroredDeployData, CompleteErroredDeployResponse, CompleteGatedDeployRequestData, CompleteGatedDeployRequestResponse, CompleteRevertData, CompleteRevertResponse, CreateBackupData, CreateBackupResponse, CreateBouncerData, CreateBouncerResponse, CreateBranchData, CreateBranchResponse, CreateDatabaseData, CreateDatabasePostgresCidrData, CreateDatabasePostgresCidrResponse, CreateDatabaseResponse, CreateDeployRequestData, CreateDeployRequestResponse, CreateKeyspaceData, CreateKeyspaceResponse, CreateOauthTokenData, CreateOauthTokenResponse, CreateOrganizationTeamData, CreateOrganizationTeamResponse, CreatePasswordData, CreatePasswordResponse, CreateQueryPatternsReportData, CreateQueryPatternsReportResponse, CreateRoleData, CreateRoleResponse, CreateServiceTokenData, CreateServiceTokenResponse, CreateWebhookData, CreateWebhookResponse, CreateWorkflowData, CreateWorkflowResponse, DeleteBackupData, DeleteBackupResponse, DeleteBouncerData, DeleteBouncerResponse, DeleteBranchData, DeleteBranchResponse, DeleteDatabaseData, DeleteDatabasePostgresCidrData, DeleteDatabasePostgresCidrResponse, DeleteDatabaseResponse, DeleteKeyspaceData, DeleteKeyspaceResponse, DeleteOauthTokenData, DeleteOauthTokenResponse, DeleteOrganizationTeamData, DeleteOrganizationTeamResponse, DeletePasswordData, DeletePasswordResponse, DeleteQueryPatternsReportData, DeleteQueryPatternsReportResponse, DeleteRoleData, DeleteRoleResponse, DeleteServiceTokenData, DeleteServiceTokenResponse, DeleteWebhookData, DeleteWebhookResponse, DemoteBranchData, DemoteBranchResponse, DisableSafeMigrationsData, DisableSafeMigrationsResponse, EnableSafeMigrationsData, EnableSafeMigrationsResponse, GetBackupData, GetBackupResponse, GetBouncerData, GetBouncerResponse, GetBranchChangeRequestData, GetBranchChangeRequestResponse, GetBranchData, GetBranchResponse, GetBranchSchemaData, GetBranchSchemaResponse, GetCurrentUserData, GetCurrentUserResponse, GetDatabaseData, GetDatabasePostgresCidrData, GetDatabasePostgresCidrResponse, GetDatabaseResponse, GetDatabaseThrottlerData, GetDatabaseThrottlerResponse, GetDefaultRoleData, GetDefaultRoleResponse, GetDeploymentData, GetDeploymentResponse, GetDeployQueueData, GetDeployQueueResponse, GetDeployRequestData, GetDeployRequestResponse, GetDeployRequestThrottlerData, GetDeployRequestThrottlerResponse, GetInvoiceData, GetInvoiceLineItemsData, GetInvoiceLineItemsResponse, GetInvoiceResponse, GetKeyspaceData, GetKeyspaceResponse, GetKeyspaceRolloutStatusData, GetKeyspaceRolloutStatusResponse, GetKeyspaceVschemaData, GetKeyspaceVschemaResponse, GetOauthApplicationData, GetOauthApplicationResponse, GetOauthTokenData, GetOauthTokenResponse, GetOrganizationData, GetOrganizationMembershipData, GetOrganizationMembershipResponse, GetOrganizationResponse, GetOrganizationTeamData, GetOrganizationTeamMemberData, GetOrganizationTeamMemberResponse, GetOrganizationTeamResponse, GetPasswordData, GetPasswordResponse, GetQueryPatternsReportData, GetQueryPatternsReportStatusData, GetQueryPatternsReportStatusResponse, GetRoleData, GetRoleResponse, GetServiceTokenData, GetServiceTokenResponse, GetWebhookData, GetWebhookResponse, GetWorkflowData, GetWorkflowResponse, LintBranchSchemaData, LintBranchSchemaResponse, ListAuditLogsData, ListAuditLogsResponse, ListBackupsData, ListBackupsResponse, ListBouncerResizeRequestsData, ListBouncerResizeRequestsResponse, ListBouncersData, ListBouncersResponse, ListBranchBouncerResizeRequestsData, ListBranchBouncerResizeRequestsResponse, ListBranchChangeRequestsData, ListBranchChangeRequestsResponse, ListBranchesData, ListBranchesResponse, ListClusterSizeSkusData, ListClusterSizeSkusResponse, ListDatabasePostgresCidrsData, ListDatabasePostgresCidrsResponse, ListDatabaseRegionsData, ListDatabaseRegionsResponse, ListDatabasesData, ListDatabasesResponse, ListDeployOperationsData, ListDeployOperationsResponse, ListDeployRequestReviewsData, ListDeployRequestReviewsResponse, ListDeployRequestsData, ListDeployRequestsResponse, ListExtensionsData, ListExtensionsResponse, ListGeneratedQueryPatternsReportsData, ListGeneratedQueryPatternsReportsResponse, ListInvoicesData, ListInvoicesResponse, ListKeyspacesData, ListKeyspacesResponse, ListOauthApplicationsData, ListOauthApplicationsResponse, ListOauthTokensData, ListOauthTokensResponse, ListOrganizationMembersData, ListOrganizationMembersResponse, ListOrganizationsData, ListOrganizationsResponse, ListOrganizationTeamMembersData, ListOrganizationTeamMembersResponse, ListOrganizationTeamsData, ListOrganizationTeamsResponse, ListParametersData, ListParametersResponse, ListPasswordsData, ListPasswordsResponse, ListPublicRegionsData, ListPublicRegionsResponse, ListReadOnlyRegionsData, ListReadOnlyRegionsResponse, ListRegionsForOrganizationData, ListRegionsForOrganizationResponse, ListRolesData, ListRolesResponse, ListServiceTokensData, ListServiceTokensResponse, ListWebhooksData, ListWebhooksResponse, ListWorkflowsData, ListWorkflowsResponse, PromoteBranchData, PromoteBranchResponse, QueueDeployRequestData, QueueDeployRequestResponse, ReassignRoleObjectsData, ReassignRoleObjectsResponse, RemoveOrganizationMemberData, RemoveOrganizationMemberResponse, RemoveOrganizationTeamMemberData, RemoveOrganizationTeamMemberResponse, RenewPasswordData, RenewPasswordResponse, RenewRoleData, RenewRoleResponse, ResetDefaultRoleData, ResetDefaultRoleResponse, ResetRoleData, ResetRoleResponse, ReviewDeployRequestData, ReviewDeployRequestResponse, SkipRevertPeriodData, SkipRevertPeriodResponse, TestWebhookData, TestWebhookResponse, UpdateAutoApplyData, UpdateAutoApplyResponse, UpdateAutoDeleteBranchData, UpdateAutoDeleteBranchResponse, UpdateBackupData, UpdateBackupResponse, UpdateBouncerResizeRequestData, UpdateBouncerResizeRequestResponse, UpdateBranchChangeRequestData, UpdateBranchChangeRequestResponse, UpdateBranchClusterConfigData, UpdateBranchClusterConfigResponse, UpdateBranchData, UpdateBranchResponse, UpdateDatabasePostgresCidrData, UpdateDatabasePostgresCidrResponse, UpdateDatabaseSettingsData, UpdateDatabaseSettingsResponse, UpdateDatabaseThrottlerData, UpdateDatabaseThrottlerResponse, UpdateDeployRequestThrottlerData, UpdateDeployRequestThrottlerResponse, UpdateKeyspaceData, UpdateKeyspaceResponse, UpdateKeyspaceVschemaData, UpdateKeyspaceVschemaResponse, UpdateOrganizationData, UpdateOrganizationMembershipData, UpdateOrganizationMembershipResponse, UpdateOrganizationResponse, UpdateOrganizationTeamData, UpdateOrganizationTeamResponse, UpdatePasswordData, UpdatePasswordResponse, UpdateRoleData, UpdateRoleResponse, UpdateWebhookData, UpdateWebhookResponse, VerifyWorkflowData, VerifyWorkflowResponse, WorkflowCancelData, WorkflowCancelResponse, WorkflowCompleteData, WorkflowCompleteResponse, WorkflowCutoverData, WorkflowCutoverResponse, WorkflowRetryData, WorkflowRetryResponse, WorkflowReverseCutoverData, WorkflowReverseCutoverResponse, WorkflowReverseTrafficData, WorkflowReverseTrafficResponse, WorkflowSwitchPrimariesData, WorkflowSwitchPrimariesResponse, WorkflowSwitchReplicasData, WorkflowSwitchReplicasResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const listOrganizationsQueryKey = (options?: Options<ListOrganizationsData>) => createQueryKey('listOrganizations', options);

/**
 * List organizations
 *
 * When using a service token, returns the list of organizations the service token has access to. When using an OAuth token, returns the list of organizations the user has access to.
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 */
export const listOrganizationsOptions = (options?: Options<ListOrganizationsData>) => queryOptions<ListOrganizationsResponse, DefaultError, ListOrganizationsResponse, ReturnType<typeof listOrganizationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOrganizations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationsQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listOrganizationsInfiniteQueryKey = (options?: Options<ListOrganizationsData>): QueryKey<Options<ListOrganizationsData>> => createQueryKey('listOrganizations', options, true);

/**
 * List organizations
 *
 * When using a service token, returns the list of organizations the service token has access to. When using an OAuth token, returns the list of organizations the user has access to.
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 */
export const listOrganizationsInfiniteOptions = (options?: Options<ListOrganizationsData>) => infiniteQueryOptions<ListOrganizationsResponse, DefaultError, InfiniteData<ListOrganizationsResponse>, QueryKey<Options<ListOrganizationsData>>, number | Pick<QueryKey<Options<ListOrganizationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListOrganizationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listOrganizations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationsInfiniteQueryKey(options)
});

export const getOrganizationQueryKey = (options: Options<GetOrganizationData>) => createQueryKey('getOrganization', options);

/**
 * Get an organization
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 * | Organization | `read_organization` |
 */
export const getOrganizationOptions = (options: Options<GetOrganizationData>) => queryOptions<GetOrganizationResponse, DefaultError, GetOrganizationResponse, ReturnType<typeof getOrganizationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOrganization({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOrganizationQueryKey(options)
});

/**
 * Update an organization
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const updateOrganizationMutation = (options?: Partial<Options<UpdateOrganizationData>>): UseMutationOptions<UpdateOrganizationResponse, DefaultError, Options<UpdateOrganizationData>> => {
    const mutationOptions: UseMutationOptions<UpdateOrganizationResponse, DefaultError, Options<UpdateOrganizationData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOrganization({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listAuditLogsQueryKey = (options: Options<ListAuditLogsData>) => createQueryKey('listAuditLogs', options);

/**
 * List audit logs
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_audit_logs`
 *
 *
 */
export const listAuditLogsOptions = (options: Options<ListAuditLogsData>) => queryOptions<ListAuditLogsResponse, DefaultError, ListAuditLogsResponse, ReturnType<typeof listAuditLogsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listAuditLogs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listAuditLogsQueryKey(options)
});

export const listClusterSizeSkusQueryKey = (options: Options<ListClusterSizeSkusData>) => createQueryKey('listClusterSizeSkus', options);

/**
 * List available cluster sizes
 *
 * List available cluster sizes for an organization
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 * | Organization | `read_organization` |
 */
export const listClusterSizeSkusOptions = (options: Options<ListClusterSizeSkusData>) => queryOptions<ListClusterSizeSkusResponse, DefaultError, ListClusterSizeSkusResponse, ReturnType<typeof listClusterSizeSkusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listClusterSizeSkus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listClusterSizeSkusQueryKey(options)
});

export const listDatabasesQueryKey = (options: Options<ListDatabasesData>) => createQueryKey('listDatabases', options);

/**
 * List databases
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 */
export const listDatabasesOptions = (options: Options<ListDatabasesData>) => queryOptions<ListDatabasesResponse, DefaultError, ListDatabasesResponse, ReturnType<typeof listDatabasesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDatabases({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabasesQueryKey(options)
});

export const listDatabasesInfiniteQueryKey = (options: Options<ListDatabasesData>): QueryKey<Options<ListDatabasesData>> => createQueryKey('listDatabases', options, true);

/**
 * List databases
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 */
export const listDatabasesInfiniteOptions = (options: Options<ListDatabasesData>) => infiniteQueryOptions<ListDatabasesResponse, DefaultError, InfiniteData<ListDatabasesResponse>, QueryKey<Options<ListDatabasesData>>, number | Pick<QueryKey<Options<ListDatabasesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDatabasesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDatabases({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabasesInfiniteQueryKey(options)
});

/**
 * Create a database
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_databases`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `create_databases` |
 */
export const createDatabaseMutation = (options?: Partial<Options<CreateDatabaseData>>): UseMutationOptions<CreateDatabaseResponse, DefaultError, Options<CreateDatabaseData>> => {
    const mutationOptions: UseMutationOptions<CreateDatabaseResponse, DefaultError, Options<CreateDatabaseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDatabase({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a database
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `delete_databases` |
 * | Database | `delete_database` |
 */
export const deleteDatabaseMutation = (options?: Partial<Options<DeleteDatabaseData>>): UseMutationOptions<DeleteDatabaseResponse, DefaultError, Options<DeleteDatabaseData>> => {
    const mutationOptions: UseMutationOptions<DeleteDatabaseResponse, DefaultError, Options<DeleteDatabaseData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDatabase({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDatabaseQueryKey = (options: Options<GetDatabaseData>) => createQueryKey('getDatabase', options);

/**
 * Get a database
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const getDatabaseOptions = (options: Options<GetDatabaseData>) => queryOptions<GetDatabaseResponse, DefaultError, GetDatabaseResponse, ReturnType<typeof getDatabaseQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDatabase({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDatabaseQueryKey(options)
});

/**
 * Update database settings
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const updateDatabaseSettingsMutation = (options?: Partial<Options<UpdateDatabaseSettingsData>>): UseMutationOptions<UpdateDatabaseSettingsResponse, DefaultError, Options<UpdateDatabaseSettingsData>> => {
    const mutationOptions: UseMutationOptions<UpdateDatabaseSettingsResponse, DefaultError, Options<UpdateDatabaseSettingsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDatabaseSettings({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBranchesQueryKey = (options: Options<ListBranchesData>) => createQueryKey('listBranches', options);

/**
 * List branches
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchesOptions = (options: Options<ListBranchesData>) => queryOptions<ListBranchesResponse, DefaultError, ListBranchesResponse, ReturnType<typeof listBranchesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBranches({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchesQueryKey(options)
});

export const listBranchesInfiniteQueryKey = (options: Options<ListBranchesData>): QueryKey<Options<ListBranchesData>> => createQueryKey('listBranches', options, true);

/**
 * List branches
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchesInfiniteOptions = (options: Options<ListBranchesData>) => infiniteQueryOptions<ListBranchesResponse, DefaultError, InfiniteData<ListBranchesResponse>, QueryKey<Options<ListBranchesData>>, number | Pick<QueryKey<Options<ListBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBranchesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBranches({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchesInfiniteQueryKey(options)
});

/**
 * Create a branch
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_branch`, `restore_production_branch_backup`, `restore_backup`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_branches`, `restore_production_branch_backups`, `restore_backups` |
 * | Database | `write_branches`, `restore_production_branch_backups`, `restore_backups` |
 * | Branch | `restore_backups` |
 */
export const createBranchMutation = (options?: Partial<Options<CreateBranchData>>): UseMutationOptions<CreateBranchResponse, DefaultError, Options<CreateBranchData>> => {
    const mutationOptions: UseMutationOptions<CreateBranchResponse, DefaultError, Options<CreateBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a branch
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `delete_branches`, `delete_production_branches` |
 * | Database | `delete_branches`, `delete_production_branches` |
 * | Branch | `delete_branch` |
 */
export const deleteBranchMutation = (options?: Partial<Options<DeleteBranchData>>): UseMutationOptions<DeleteBranchResponse, DefaultError, Options<DeleteBranchData>> => {
    const mutationOptions: UseMutationOptions<DeleteBranchResponse, DefaultError, Options<DeleteBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBranchQueryKey = (options: Options<GetBranchData>) => createQueryKey('getBranch', options);

/**
 * Get a branch
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getBranchOptions = (options: Options<GetBranchData>) => queryOptions<GetBranchResponse, DefaultError, GetBranchResponse, ReturnType<typeof getBranchQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBranch({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBranchQueryKey(options)
});

/**
 * Update a branch
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_branches` |
 * | Database | `write_branches` |
 * | Branch | `write_branch` |
 */
export const updateBranchMutation = (options?: Partial<Options<UpdateBranchData>>): UseMutationOptions<UpdateBranchResponse, DefaultError, Options<UpdateBranchData>> => {
    const mutationOptions: UseMutationOptions<UpdateBranchResponse, DefaultError, Options<UpdateBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBackupsQueryKey = (options: Options<ListBackupsData>) => createQueryKey('listBackups', options);

/**
 * List backups
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_backups` |
 * | Database | `read_backups` |
 * | Branch | `read_backups` |
 */
export const listBackupsOptions = (options: Options<ListBackupsData>) => queryOptions<ListBackupsResponse, DefaultError, ListBackupsResponse, ReturnType<typeof listBackupsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBackups({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBackupsQueryKey(options)
});

export const listBackupsInfiniteQueryKey = (options: Options<ListBackupsData>): QueryKey<Options<ListBackupsData>> => createQueryKey('listBackups', options, true);

/**
 * List backups
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_backups` |
 * | Database | `read_backups` |
 * | Branch | `read_backups` |
 */
export const listBackupsInfiniteOptions = (options: Options<ListBackupsData>) => infiniteQueryOptions<ListBackupsResponse, DefaultError, InfiniteData<ListBackupsResponse>, QueryKey<Options<ListBackupsData>>, number | Pick<QueryKey<Options<ListBackupsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBackupsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBackups({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBackupsInfiniteQueryKey(options)
});

/**
 * Create a backup
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_backups` |
 * | Database | `write_backups` |
 * | Branch | `write_backups` |
 */
export const createBackupMutation = (options?: Partial<Options<CreateBackupData>>): UseMutationOptions<CreateBackupResponse, DefaultError, Options<CreateBackupData>> => {
    const mutationOptions: UseMutationOptions<CreateBackupResponse, DefaultError, Options<CreateBackupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBackup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a backup
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_backups`, `delete_production_branch_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `delete_backups`, `delete_production_branch_backups` |
 * | Database | `delete_backups`, `delete_production_branch_backups` |
 * | Branch | `delete_backups` |
 */
export const deleteBackupMutation = (options?: Partial<Options<DeleteBackupData>>): UseMutationOptions<DeleteBackupResponse, DefaultError, Options<DeleteBackupData>> => {
    const mutationOptions: UseMutationOptions<DeleteBackupResponse, DefaultError, Options<DeleteBackupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBackup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupQueryKey = (options: Options<GetBackupData>) => createQueryKey('getBackup', options);

/**
 * Get a backup
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_backups` |
 * | Database | `read_backups` |
 * | Branch | `read_backups` |
 */
export const getBackupOptions = (options: Options<GetBackupData>) => queryOptions<GetBackupResponse, DefaultError, GetBackupResponse, ReturnType<typeof getBackupQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBackup({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBackupQueryKey(options)
});

/**
 * Update a backup
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_backups`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_backups` |
 * | Database | `write_backups` |
 * | Branch | `write_backups` |
 */
export const updateBackupMutation = (options?: Partial<Options<UpdateBackupData>>): UseMutationOptions<UpdateBackupResponse, DefaultError, Options<UpdateBackupData>> => {
    const mutationOptions: UseMutationOptions<UpdateBackupResponse, DefaultError, Options<UpdateBackupData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBackup({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBranchBouncerResizeRequestsQueryKey = (options: Options<ListBranchBouncerResizeRequestsData>) => createQueryKey('listBranchBouncerResizeRequests', options);

/**
 * Get bouncer resize requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchBouncerResizeRequestsOptions = (options: Options<ListBranchBouncerResizeRequestsData>) => queryOptions<ListBranchBouncerResizeRequestsResponse, DefaultError, ListBranchBouncerResizeRequestsResponse, ReturnType<typeof listBranchBouncerResizeRequestsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBranchBouncerResizeRequests({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchBouncerResizeRequestsQueryKey(options)
});

export const listBranchBouncerResizeRequestsInfiniteQueryKey = (options: Options<ListBranchBouncerResizeRequestsData>): QueryKey<Options<ListBranchBouncerResizeRequestsData>> => createQueryKey('listBranchBouncerResizeRequests', options, true);

/**
 * Get bouncer resize requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchBouncerResizeRequestsInfiniteOptions = (options: Options<ListBranchBouncerResizeRequestsData>) => infiniteQueryOptions<ListBranchBouncerResizeRequestsResponse, DefaultError, InfiniteData<ListBranchBouncerResizeRequestsResponse>, QueryKey<Options<ListBranchBouncerResizeRequestsData>>, number | Pick<QueryKey<Options<ListBranchBouncerResizeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBranchBouncerResizeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBranchBouncerResizeRequests({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchBouncerResizeRequestsInfiniteQueryKey(options)
});

export const listBouncersQueryKey = (options: Options<ListBouncersData>) => createQueryKey('listBouncers', options);

/**
 * List bouncers
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBouncersOptions = (options: Options<ListBouncersData>) => queryOptions<ListBouncersResponse, DefaultError, ListBouncersResponse, ReturnType<typeof listBouncersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBouncers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBouncersQueryKey(options)
});

export const listBouncersInfiniteQueryKey = (options: Options<ListBouncersData>): QueryKey<Options<ListBouncersData>> => createQueryKey('listBouncers', options, true);

/**
 * List bouncers
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBouncersInfiniteOptions = (options: Options<ListBouncersData>) => infiniteQueryOptions<ListBouncersResponse, DefaultError, InfiniteData<ListBouncersResponse>, QueryKey<Options<ListBouncersData>>, number | Pick<QueryKey<Options<ListBouncersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBouncersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBouncers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBouncersInfiniteQueryKey(options)
});

/**
 * Create a bouncer
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const createBouncerMutation = (options?: Partial<Options<CreateBouncerData>>): UseMutationOptions<CreateBouncerResponse, DefaultError, Options<CreateBouncerData>> => {
    const mutationOptions: UseMutationOptions<CreateBouncerResponse, DefaultError, Options<CreateBouncerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createBouncer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a bouncer
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const deleteBouncerMutation = (options?: Partial<Options<DeleteBouncerData>>): UseMutationOptions<DeleteBouncerResponse, DefaultError, Options<DeleteBouncerData>> => {
    const mutationOptions: UseMutationOptions<DeleteBouncerResponse, DefaultError, Options<DeleteBouncerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteBouncer({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBouncerQueryKey = (options: Options<GetBouncerData>) => createQueryKey('getBouncer', options);

/**
 * Get a bouncer
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getBouncerOptions = (options: Options<GetBouncerData>) => queryOptions<GetBouncerResponse, DefaultError, GetBouncerResponse, ReturnType<typeof getBouncerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBouncer({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBouncerQueryKey(options)
});

/**
 * Cancel a resize request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const cancelBouncerResizeRequestMutation = (options?: Partial<Options<CancelBouncerResizeRequestData>>): UseMutationOptions<CancelBouncerResizeRequestResponse, DefaultError, Options<CancelBouncerResizeRequestData>> => {
    const mutationOptions: UseMutationOptions<CancelBouncerResizeRequestResponse, DefaultError, Options<CancelBouncerResizeRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelBouncerResizeRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBouncerResizeRequestsQueryKey = (options: Options<ListBouncerResizeRequestsData>) => createQueryKey('listBouncerResizeRequests', options);

/**
 * Get bouncer resize requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBouncerResizeRequestsOptions = (options: Options<ListBouncerResizeRequestsData>) => queryOptions<ListBouncerResizeRequestsResponse, DefaultError, ListBouncerResizeRequestsResponse, ReturnType<typeof listBouncerResizeRequestsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBouncerResizeRequests({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBouncerResizeRequestsQueryKey(options)
});

export const listBouncerResizeRequestsInfiniteQueryKey = (options: Options<ListBouncerResizeRequestsData>): QueryKey<Options<ListBouncerResizeRequestsData>> => createQueryKey('listBouncerResizeRequests', options, true);

/**
 * Get bouncer resize requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBouncerResizeRequestsInfiniteOptions = (options: Options<ListBouncerResizeRequestsData>) => infiniteQueryOptions<ListBouncerResizeRequestsResponse, DefaultError, InfiniteData<ListBouncerResizeRequestsResponse>, QueryKey<Options<ListBouncerResizeRequestsData>>, number | Pick<QueryKey<Options<ListBouncerResizeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBouncerResizeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBouncerResizeRequests({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBouncerResizeRequestsInfiniteQueryKey(options)
});

/**
 * Upsert a bouncer resize request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const updateBouncerResizeRequestMutation = (options?: Partial<Options<UpdateBouncerResizeRequestData>>): UseMutationOptions<UpdateBouncerResizeRequestResponse, DefaultError, Options<UpdateBouncerResizeRequestData>> => {
    const mutationOptions: UseMutationOptions<UpdateBouncerResizeRequestResponse, DefaultError, Options<UpdateBouncerResizeRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBouncerResizeRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listBranchChangeRequestsQueryKey = (options: Options<ListBranchChangeRequestsData>) => createQueryKey('listBranchChangeRequests', options);

/**
 * Get branch change requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchChangeRequestsOptions = (options: Options<ListBranchChangeRequestsData>) => queryOptions<ListBranchChangeRequestsResponse, DefaultError, ListBranchChangeRequestsResponse, ReturnType<typeof listBranchChangeRequestsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listBranchChangeRequests({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchChangeRequestsQueryKey(options)
});

export const listBranchChangeRequestsInfiniteQueryKey = (options: Options<ListBranchChangeRequestsData>): QueryKey<Options<ListBranchChangeRequestsData>> => createQueryKey('listBranchChangeRequests', options, true);

/**
 * Get branch change requests
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listBranchChangeRequestsInfiniteOptions = (options: Options<ListBranchChangeRequestsData>) => infiniteQueryOptions<ListBranchChangeRequestsResponse, DefaultError, InfiniteData<ListBranchChangeRequestsResponse>, QueryKey<Options<ListBranchChangeRequestsData>>, number | Pick<QueryKey<Options<ListBranchChangeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListBranchChangeRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBranchChangeRequests({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listBranchChangeRequestsInfiniteQueryKey(options)
});

/**
 * Upsert a change request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const updateBranchChangeRequestMutation = (options?: Partial<Options<UpdateBranchChangeRequestData>>): UseMutationOptions<UpdateBranchChangeRequestResponse, DefaultError, Options<UpdateBranchChangeRequestData>> => {
    const mutationOptions: UseMutationOptions<UpdateBranchChangeRequestResponse, DefaultError, Options<UpdateBranchChangeRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBranchChangeRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBranchChangeRequestQueryKey = (options: Options<GetBranchChangeRequestData>) => createQueryKey('getBranchChangeRequest', options);

/**
 * Get a branch change request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getBranchChangeRequestOptions = (options: Options<GetBranchChangeRequestData>) => queryOptions<GetBranchChangeRequestResponse, DefaultError, GetBranchChangeRequestResponse, ReturnType<typeof getBranchChangeRequestQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBranchChangeRequest({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBranchChangeRequestQueryKey(options)
});

/**
 * Change a branch cluster configuration
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 *
 */
export const updateBranchClusterConfigMutation = (options?: Partial<Options<UpdateBranchClusterConfigData>>): UseMutationOptions<UpdateBranchClusterConfigResponse, DefaultError, Options<UpdateBranchClusterConfigData>> => {
    const mutationOptions: UseMutationOptions<UpdateBranchClusterConfigResponse, DefaultError, Options<UpdateBranchClusterConfigData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateBranchClusterConfig({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Demote a branch
 *
 * Demotes a branch from production to development
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `connect_production_branch`, `demote_branches`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `demote_branches` |
 * | Database | `demote_branches` |
 */
export const demoteBranchMutation = (options?: Partial<Options<DemoteBranchData>>): UseMutationOptions<DemoteBranchResponse, DefaultError, Options<DemoteBranchData>> => {
    const mutationOptions: UseMutationOptions<DemoteBranchResponse, DefaultError, Options<DemoteBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await demoteBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listExtensionsQueryKey = (options: Options<ListExtensionsData>) => createQueryKey('listExtensions', options);

/**
 * List cluster extensions
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listExtensionsOptions = (options: Options<ListExtensionsData>) => queryOptions<ListExtensionsResponse, DefaultError, ListExtensionsResponse, ReturnType<typeof listExtensionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listExtensions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listExtensionsQueryKey(options)
});

export const listKeyspacesQueryKey = (options: Options<ListKeyspacesData>) => createQueryKey('listKeyspaces', options);

/**
 * Get keyspaces
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 *
 */
export const listKeyspacesOptions = (options: Options<ListKeyspacesData>) => queryOptions<ListKeyspacesResponse, DefaultError, ListKeyspacesResponse, ReturnType<typeof listKeyspacesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listKeyspaces({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listKeyspacesQueryKey(options)
});

export const listKeyspacesInfiniteQueryKey = (options: Options<ListKeyspacesData>): QueryKey<Options<ListKeyspacesData>> => createQueryKey('listKeyspaces', options, true);

/**
 * Get keyspaces
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 *
 */
export const listKeyspacesInfiniteOptions = (options: Options<ListKeyspacesData>) => infiniteQueryOptions<ListKeyspacesResponse, DefaultError, InfiniteData<ListKeyspacesResponse>, QueryKey<Options<ListKeyspacesData>>, number | Pick<QueryKey<Options<ListKeyspacesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListKeyspacesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listKeyspaces({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listKeyspacesInfiniteQueryKey(options)
});

/**
 * Create a keyspace
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_branch`
 *
 *
 */
export const createKeyspaceMutation = (options?: Partial<Options<CreateKeyspaceData>>): UseMutationOptions<CreateKeyspaceResponse, DefaultError, Options<CreateKeyspaceData>> => {
    const mutationOptions: UseMutationOptions<CreateKeyspaceResponse, DefaultError, Options<CreateKeyspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createKeyspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a keyspace
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_branch`, `delete_production_branch`
 *
 *
 */
export const deleteKeyspaceMutation = (options?: Partial<Options<DeleteKeyspaceData>>): UseMutationOptions<DeleteKeyspaceResponse, DefaultError, Options<DeleteKeyspaceData>> => {
    const mutationOptions: UseMutationOptions<DeleteKeyspaceResponse, DefaultError, Options<DeleteKeyspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteKeyspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeyspaceQueryKey = (options: Options<GetKeyspaceData>) => createQueryKey('getKeyspace', options);

/**
 * Get a keyspace
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 *
 */
export const getKeyspaceOptions = (options: Options<GetKeyspaceData>) => queryOptions<GetKeyspaceResponse, DefaultError, GetKeyspaceResponse, ReturnType<typeof getKeyspaceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getKeyspace({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getKeyspaceQueryKey(options)
});

/**
 * Configure keyspace settings
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_branch`
 *
 *
 */
export const updateKeyspaceMutation = (options?: Partial<Options<UpdateKeyspaceData>>): UseMutationOptions<UpdateKeyspaceResponse, DefaultError, Options<UpdateKeyspaceData>> => {
    const mutationOptions: UseMutationOptions<UpdateKeyspaceResponse, DefaultError, Options<UpdateKeyspaceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateKeyspace({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeyspaceRolloutStatusQueryKey = (options: Options<GetKeyspaceRolloutStatusData>) => createQueryKey('getKeyspaceRolloutStatus', options);

/**
 * Get keyspace rollout status
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 *
 */
export const getKeyspaceRolloutStatusOptions = (options: Options<GetKeyspaceRolloutStatusData>) => queryOptions<GetKeyspaceRolloutStatusResponse, DefaultError, GetKeyspaceRolloutStatusResponse, ReturnType<typeof getKeyspaceRolloutStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getKeyspaceRolloutStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getKeyspaceRolloutStatusQueryKey(options)
});

export const getKeyspaceVschemaQueryKey = (options: Options<GetKeyspaceVschemaData>) => createQueryKey('getKeyspaceVschema', options);

/**
 * Get the VSchema for the keyspace
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 *
 */
export const getKeyspaceVschemaOptions = (options: Options<GetKeyspaceVschemaData>) => queryOptions<GetKeyspaceVschemaResponse, DefaultError, GetKeyspaceVschemaResponse, ReturnType<typeof getKeyspaceVschemaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getKeyspaceVschema({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getKeyspaceVschemaQueryKey(options)
});

/**
 * Update the VSchema for the keyspace
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_production_branch_vschema`, `write_branch_vschema`
 *
 *
 */
export const updateKeyspaceVschemaMutation = (options?: Partial<Options<UpdateKeyspaceVschemaData>>): UseMutationOptions<UpdateKeyspaceVschemaResponse, DefaultError, Options<UpdateKeyspaceVschemaData>> => {
    const mutationOptions: UseMutationOptions<UpdateKeyspaceVschemaResponse, DefaultError, Options<UpdateKeyspaceVschemaData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateKeyspaceVschema({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listParametersQueryKey = (options: Options<ListParametersData>) => createQueryKey('listParameters', options);

/**
 * List cluster parameters
 *
 *         Returns the parameters for a branch. To update the parameters, use the "Upsert a change request" endpoint.
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listParametersOptions = (options: Options<ListParametersData>) => queryOptions<ListParametersResponse, DefaultError, ListParametersResponse, ReturnType<typeof listParametersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listParameters({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listParametersQueryKey(options)
});

export const listPasswordsQueryKey = (options: Options<ListPasswordsData>) => createQueryKey('listPasswords', options);

/**
 * List passwords
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const listPasswordsOptions = (options: Options<ListPasswordsData>) => queryOptions<ListPasswordsResponse, DefaultError, ListPasswordsResponse, ReturnType<typeof listPasswordsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPasswords({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPasswordsQueryKey(options)
});

export const listPasswordsInfiniteQueryKey = (options: Options<ListPasswordsData>): QueryKey<Options<ListPasswordsData>> => createQueryKey('listPasswords', options, true);

/**
 * List passwords
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const listPasswordsInfiniteOptions = (options: Options<ListPasswordsData>) => infiniteQueryOptions<ListPasswordsResponse, DefaultError, InfiniteData<ListPasswordsResponse>, QueryKey<Options<ListPasswordsData>>, number | Pick<QueryKey<Options<ListPasswordsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPasswordsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPasswords({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPasswordsInfiniteQueryKey(options)
});

/**
 * Create a password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const createPasswordMutation = (options?: Partial<Options<CreatePasswordData>>): UseMutationOptions<CreatePasswordResponse, DefaultError, Options<CreatePasswordData>> => {
    const mutationOptions: UseMutationOptions<CreatePasswordResponse, DefaultError, Options<CreatePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_production_branch_password`, `delete_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const deletePasswordMutation = (options?: Partial<Options<DeletePasswordData>>): UseMutationOptions<DeletePasswordResponse, DefaultError, Options<DeletePasswordData>> => {
    const mutationOptions: UseMutationOptions<DeletePasswordResponse, DefaultError, Options<DeletePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPasswordQueryKey = (options: Options<GetPasswordData>) => createQueryKey('getPassword', options);

/**
 * Get a password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const getPasswordOptions = (options: Options<GetPasswordData>) => queryOptions<GetPasswordResponse, DefaultError, GetPasswordResponse, ReturnType<typeof getPasswordQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPassword({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPasswordQueryKey(options)
});

/**
 * Update a password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const updatePasswordMutation = (options?: Partial<Options<UpdatePasswordData>>): UseMutationOptions<UpdatePasswordResponse, DefaultError, Options<UpdatePasswordData>> => {
    const mutationOptions: UseMutationOptions<UpdatePasswordResponse, DefaultError, Options<UpdatePasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Renew a password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const renewPasswordMutation = (options?: Partial<Options<RenewPasswordData>>): UseMutationOptions<RenewPasswordResponse, DefaultError, Options<RenewPasswordData>> => {
    const mutationOptions: UseMutationOptions<RenewPasswordResponse, DefaultError, Options<RenewPasswordData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await renewPassword({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Promote a branch
 *
 * Promotes a branch from development to production
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `connect_production_branch`, `promote_branches`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `promote_branches` |
 * | Database | `promote_branches` |
 */
export const promoteBranchMutation = (options?: Partial<Options<PromoteBranchData>>): UseMutationOptions<PromoteBranchResponse, DefaultError, Options<PromoteBranchData>> => {
    const mutationOptions: UseMutationOptions<PromoteBranchResponse, DefaultError, Options<PromoteBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await promoteBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listGeneratedQueryPatternsReportsQueryKey = (options: Options<ListGeneratedQueryPatternsReportsData>) => createQueryKey('listGeneratedQueryPatternsReports', options);

/**
 * List generated query patterns reports
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const listGeneratedQueryPatternsReportsOptions = (options: Options<ListGeneratedQueryPatternsReportsData>) => queryOptions<ListGeneratedQueryPatternsReportsResponse, DefaultError, ListGeneratedQueryPatternsReportsResponse, ReturnType<typeof listGeneratedQueryPatternsReportsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listGeneratedQueryPatternsReports({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listGeneratedQueryPatternsReportsQueryKey(options)
});

/**
 * Create a new query patterns report
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const createQueryPatternsReportMutation = (options?: Partial<Options<CreateQueryPatternsReportData>>): UseMutationOptions<CreateQueryPatternsReportResponse, DefaultError, Options<CreateQueryPatternsReportData>> => {
    const mutationOptions: UseMutationOptions<CreateQueryPatternsReportResponse, DefaultError, Options<CreateQueryPatternsReportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createQueryPatternsReport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a query patterns report
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const deleteQueryPatternsReportMutation = (options?: Partial<Options<DeleteQueryPatternsReportData>>): UseMutationOptions<DeleteQueryPatternsReportResponse, DefaultError, Options<DeleteQueryPatternsReportData>> => {
    const mutationOptions: UseMutationOptions<DeleteQueryPatternsReportResponse, DefaultError, Options<DeleteQueryPatternsReportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteQueryPatternsReport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getQueryPatternsReportStatusQueryKey = (options: Options<GetQueryPatternsReportStatusData>) => createQueryKey('getQueryPatternsReportStatus', options);

/**
 * Show the status of a query patterns report
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getQueryPatternsReportStatusOptions = (options: Options<GetQueryPatternsReportStatusData>) => queryOptions<GetQueryPatternsReportStatusResponse, DefaultError, GetQueryPatternsReportStatusResponse, ReturnType<typeof getQueryPatternsReportStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getQueryPatternsReportStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getQueryPatternsReportStatusQueryKey(options)
});

export const getQueryPatternsReportQueryKey = (options: Options<GetQueryPatternsReportData>) => createQueryKey('getQueryPatternsReport', options);

/**
 * Download a finished query patterns report
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getQueryPatternsReportOptions = (options: Options<GetQueryPatternsReportData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getQueryPatternsReportQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getQueryPatternsReport({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getQueryPatternsReportQueryKey(options)
});

/**
 * Cancel a change request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const cancelBranchChangeRequestMutation = (options?: Partial<Options<CancelBranchChangeRequestData>>): UseMutationOptions<CancelBranchChangeRequestResponse, DefaultError, Options<CancelBranchChangeRequestData>> => {
    const mutationOptions: UseMutationOptions<CancelBranchChangeRequestResponse, DefaultError, Options<CancelBranchChangeRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelBranchChangeRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRolesQueryKey = (options: Options<ListRolesData>) => createQueryKey('listRoles', options);

/**
 * List roles
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const listRolesOptions = (options: Options<ListRolesData>) => queryOptions<ListRolesResponse, DefaultError, ListRolesResponse, ReturnType<typeof listRolesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listRoles({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRolesQueryKey(options)
});

export const listRolesInfiniteQueryKey = (options: Options<ListRolesData>): QueryKey<Options<ListRolesData>> => createQueryKey('listRoles', options, true);

/**
 * List roles
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const listRolesInfiniteOptions = (options: Options<ListRolesData>) => infiniteQueryOptions<ListRolesResponse, DefaultError, InfiniteData<ListRolesResponse>, QueryKey<Options<ListRolesData>>, number | Pick<QueryKey<Options<ListRolesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListRolesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listRoles({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRolesInfiniteQueryKey(options)
});

/**
 * Create role credentials
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_production_branch_password`, `create_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const createRoleMutation = (options?: Partial<Options<CreateRoleData>>): UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> => {
    const mutationOptions: UseMutationOptions<CreateRoleResponse, DefaultError, Options<CreateRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDefaultRoleQueryKey = (options: Options<GetDefaultRoleData>) => createQueryKey('getDefaultRole', options);

/**
 * Get the default postgres role
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const getDefaultRoleOptions = (options: Options<GetDefaultRoleData>) => queryOptions<GetDefaultRoleResponse, DefaultError, GetDefaultRoleResponse, ReturnType<typeof getDefaultRoleQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDefaultRole({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDefaultRoleQueryKey(options)
});

/**
 * Reset default credentials
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_production_branch_password`, `delete_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const resetDefaultRoleMutation = (options?: Partial<Options<ResetDefaultRoleData>>): UseMutationOptions<ResetDefaultRoleResponse, DefaultError, Options<ResetDefaultRoleData>> => {
    const mutationOptions: UseMutationOptions<ResetDefaultRoleResponse, DefaultError, Options<ResetDefaultRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetDefaultRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role credentials
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_production_branch_password`, `delete_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const deleteRoleMutation = (options?: Partial<Options<DeleteRoleData>>): UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRoleResponse, DefaultError, Options<DeleteRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getRoleQueryKey = (options: Options<GetRoleData>) => createQueryKey('getRole', options);

/**
 * Get a role
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const getRoleOptions = (options: Options<GetRoleData>) => queryOptions<GetRoleResponse, DefaultError, GetRoleResponse, ReturnType<typeof getRoleQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getRole({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getRoleQueryKey(options)
});

/**
 * Update role name
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_production_branch_password`, `create_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const updateRoleMutation = (options?: Partial<Options<UpdateRoleData>>): UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRoleResponse, DefaultError, Options<UpdateRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reassign objects owned by one role to another role
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_production_branch_password`, `delete_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const reassignRoleObjectsMutation = (options?: Partial<Options<ReassignRoleObjectsData>>): UseMutationOptions<ReassignRoleObjectsResponse, DefaultError, Options<ReassignRoleObjectsData>> => {
    const mutationOptions: UseMutationOptions<ReassignRoleObjectsResponse, DefaultError, Options<ReassignRoleObjectsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reassignRoleObjects({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Renew role expiration
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `create_production_branch_password`, `create_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const renewRoleMutation = (options?: Partial<Options<RenewRoleData>>): UseMutationOptions<RenewRoleResponse, DefaultError, Options<RenewRoleData>> => {
    const mutationOptions: UseMutationOptions<RenewRoleResponse, DefaultError, Options<RenewRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await renewRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset a role's password
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_production_branch_password`, `delete_branch_password`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `manage_passwords`, `manage_production_branch_passwords` |
 * | Database | `manage_passwords`, `manage_production_branch_passwords` |
 * | Branch | `manage_passwords` |
 */
export const resetRoleMutation = (options?: Partial<Options<ResetRoleData>>): UseMutationOptions<ResetRoleResponse, DefaultError, Options<ResetRoleData>> => {
    const mutationOptions: UseMutationOptions<ResetRoleResponse, DefaultError, Options<ResetRoleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await resetRole({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disable safe migrations for a branch
 *
 *
 *
 */
export const disableSafeMigrationsMutation = (options?: Partial<Options<DisableSafeMigrationsData>>): UseMutationOptions<DisableSafeMigrationsResponse, DefaultError, Options<DisableSafeMigrationsData>> => {
    const mutationOptions: UseMutationOptions<DisableSafeMigrationsResponse, DefaultError, Options<DisableSafeMigrationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await disableSafeMigrations({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable safe migrations for a branch
 *
 *
 *
 */
export const enableSafeMigrationsMutation = (options?: Partial<Options<EnableSafeMigrationsData>>): UseMutationOptions<EnableSafeMigrationsResponse, DefaultError, Options<EnableSafeMigrationsData>> => {
    const mutationOptions: UseMutationOptions<EnableSafeMigrationsResponse, DefaultError, Options<EnableSafeMigrationsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await enableSafeMigrations({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBranchSchemaQueryKey = (options: Options<GetBranchSchemaData>) => createQueryKey('getBranchSchema', options);

/**
 * Get a branch schema
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const getBranchSchemaOptions = (options: Options<GetBranchSchemaData>) => queryOptions<GetBranchSchemaResponse, DefaultError, GetBranchSchemaResponse, ReturnType<typeof getBranchSchemaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBranchSchema({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBranchSchemaQueryKey(options)
});

export const lintBranchSchemaQueryKey = (options: Options<LintBranchSchemaData>) => createQueryKey('lintBranchSchema', options);

/**
 * Lint a branch schema
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const lintBranchSchemaOptions = (options: Options<LintBranchSchemaData>) => queryOptions<LintBranchSchemaResponse, DefaultError, LintBranchSchemaResponse, ReturnType<typeof lintBranchSchemaQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await lintBranchSchema({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: lintBranchSchemaQueryKey(options)
});

export const lintBranchSchemaInfiniteQueryKey = (options: Options<LintBranchSchemaData>): QueryKey<Options<LintBranchSchemaData>> => createQueryKey('lintBranchSchema', options, true);

/**
 * Lint a branch schema
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_branch`, `delete_branch`, `create_branch`, `connect_production_branch`, `connect_branch`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 * | Branch | `read_branch` |
 */
export const lintBranchSchemaInfiniteOptions = (options: Options<LintBranchSchemaData>) => infiniteQueryOptions<LintBranchSchemaResponse, DefaultError, InfiniteData<LintBranchSchemaResponse>, QueryKey<Options<LintBranchSchemaData>>, number | Pick<QueryKey<Options<LintBranchSchemaData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<LintBranchSchemaData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await lintBranchSchema({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: lintBranchSchemaInfiniteQueryKey(options)
});

export const listDatabasePostgresCidrsQueryKey = (options: Options<ListDatabasePostgresCidrsData>) => createQueryKey('listDatabasePostgresCidrs', options);

/**
 * List IP restriction entries
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listDatabasePostgresCidrsOptions = (options: Options<ListDatabasePostgresCidrsData>) => queryOptions<ListDatabasePostgresCidrsResponse, DefaultError, ListDatabasePostgresCidrsResponse, ReturnType<typeof listDatabasePostgresCidrsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDatabasePostgresCidrs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabasePostgresCidrsQueryKey(options)
});

export const listDatabasePostgresCidrsInfiniteQueryKey = (options: Options<ListDatabasePostgresCidrsData>): QueryKey<Options<ListDatabasePostgresCidrsData>> => createQueryKey('listDatabasePostgresCidrs', options, true);

/**
 * List IP restriction entries
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listDatabasePostgresCidrsInfiniteOptions = (options: Options<ListDatabasePostgresCidrsData>) => infiniteQueryOptions<ListDatabasePostgresCidrsResponse, DefaultError, InfiniteData<ListDatabasePostgresCidrsResponse>, QueryKey<Options<ListDatabasePostgresCidrsData>>, number | Pick<QueryKey<Options<ListDatabasePostgresCidrsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDatabasePostgresCidrsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDatabasePostgresCidrs({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabasePostgresCidrsInfiniteQueryKey(options)
});

/**
 * Create an IP restriction entry
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const createDatabasePostgresCidrMutation = (options?: Partial<Options<CreateDatabasePostgresCidrData>>): UseMutationOptions<CreateDatabasePostgresCidrResponse, DefaultError, Options<CreateDatabasePostgresCidrData>> => {
    const mutationOptions: UseMutationOptions<CreateDatabasePostgresCidrResponse, DefaultError, Options<CreateDatabasePostgresCidrData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDatabasePostgresCidr({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an IP restriction entry
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const deleteDatabasePostgresCidrMutation = (options?: Partial<Options<DeleteDatabasePostgresCidrData>>): UseMutationOptions<DeleteDatabasePostgresCidrResponse, DefaultError, Options<DeleteDatabasePostgresCidrData>> => {
    const mutationOptions: UseMutationOptions<DeleteDatabasePostgresCidrResponse, DefaultError, Options<DeleteDatabasePostgresCidrData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteDatabasePostgresCidr({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDatabasePostgresCidrQueryKey = (options: Options<GetDatabasePostgresCidrData>) => createQueryKey('getDatabasePostgresCidr', options);

/**
 * Get an IP restriction entry
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const getDatabasePostgresCidrOptions = (options: Options<GetDatabasePostgresCidrData>) => queryOptions<GetDatabasePostgresCidrResponse, DefaultError, GetDatabasePostgresCidrResponse, ReturnType<typeof getDatabasePostgresCidrQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDatabasePostgresCidr({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDatabasePostgresCidrQueryKey(options)
});

/**
 * Update an IP restriction entry
 *
 *
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const updateDatabasePostgresCidrMutation = (options?: Partial<Options<UpdateDatabasePostgresCidrData>>): UseMutationOptions<UpdateDatabasePostgresCidrResponse, DefaultError, Options<UpdateDatabasePostgresCidrData>> => {
    const mutationOptions: UseMutationOptions<UpdateDatabasePostgresCidrResponse, DefaultError, Options<UpdateDatabasePostgresCidrData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDatabasePostgresCidr({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeployQueueQueryKey = (options: Options<GetDeployQueueData>) => createQueryKey('getDeployQueue', options);

/**
 * Get the deploy queue
 *
 * The deploy queue returns the current list of deploy requests in the order they will be deployed.
 *
 */
export const getDeployQueueOptions = (options: Options<GetDeployQueueData>) => queryOptions<GetDeployQueueResponse, DefaultError, GetDeployQueueResponse, ReturnType<typeof getDeployQueueQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployQueue({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeployQueueQueryKey(options)
});

export const listDeployRequestsQueryKey = (options: Options<ListDeployRequestsData>) => createQueryKey('listDeployRequests', options);

/**
 * List deploy requests
 *
 * List deploy requests for a database
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const listDeployRequestsOptions = (options: Options<ListDeployRequestsData>) => queryOptions<ListDeployRequestsResponse, DefaultError, ListDeployRequestsResponse, ReturnType<typeof listDeployRequestsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDeployRequests({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDeployRequestsQueryKey(options)
});

export const listDeployRequestsInfiniteQueryKey = (options: Options<ListDeployRequestsData>): QueryKey<Options<ListDeployRequestsData>> => createQueryKey('listDeployRequests', options, true);

/**
 * List deploy requests
 *
 * List deploy requests for a database
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const listDeployRequestsInfiniteOptions = (options: Options<ListDeployRequestsData>) => infiniteQueryOptions<ListDeployRequestsResponse, DefaultError, InfiniteData<ListDeployRequestsResponse>, QueryKey<Options<ListDeployRequestsData>>, number | Pick<QueryKey<Options<ListDeployRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDeployRequestsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDeployRequests({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDeployRequestsInfiniteQueryKey(options)
});

/**
 * Create a deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_requests`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_deploy_requests` |
 * | Database | `write_deploy_requests` |
 */
export const createDeployRequestMutation = (options?: Partial<Options<CreateDeployRequestData>>): UseMutationOptions<CreateDeployRequestResponse, DefaultError, Options<CreateDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<CreateDeployRequestResponse, DefaultError, Options<CreateDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeployRequestQueryKey = (options: Options<GetDeployRequestData>) => createQueryKey('getDeployRequest', options);

/**
 * Get a deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const getDeployRequestOptions = (options: Options<GetDeployRequestData>) => queryOptions<GetDeployRequestResponse, DefaultError, GetDeployRequestResponse, ReturnType<typeof getDeployRequestQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployRequest({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeployRequestQueryKey(options)
});

/**
 * Close a deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_deploy_requests` |
 * | Database | `write_deploy_requests` |
 */
export const closeDeployRequestMutation = (options?: Partial<Options<CloseDeployRequestData>>): UseMutationOptions<CloseDeployRequestResponse, DefaultError, Options<CloseDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<CloseDeployRequestResponse, DefaultError, Options<CloseDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await closeDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete a gated deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const completeGatedDeployRequestMutation = (options?: Partial<Options<CompleteGatedDeployRequestData>>): UseMutationOptions<CompleteGatedDeployRequestResponse, DefaultError, Options<CompleteGatedDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<CompleteGatedDeployRequestResponse, DefaultError, Options<CompleteGatedDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await completeGatedDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update auto-apply for deploy request
 *
 * Enables or disabled the auto-apply setting for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const updateAutoApplyMutation = (options?: Partial<Options<UpdateAutoApplyData>>): UseMutationOptions<UpdateAutoApplyResponse, DefaultError, Options<UpdateAutoApplyData>> => {
    const mutationOptions: UseMutationOptions<UpdateAutoApplyResponse, DefaultError, Options<UpdateAutoApplyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAutoApply({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update auto-delete branch for deploy request
 *
 * Enables or disabled the auto-delete branch setting for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const updateAutoDeleteBranchMutation = (options?: Partial<Options<UpdateAutoDeleteBranchData>>): UseMutationOptions<UpdateAutoDeleteBranchResponse, DefaultError, Options<UpdateAutoDeleteBranchData>> => {
    const mutationOptions: UseMutationOptions<UpdateAutoDeleteBranchResponse, DefaultError, Options<UpdateAutoDeleteBranchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateAutoDeleteBranch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel a queued deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const cancelDeployRequestMutation = (options?: Partial<Options<CancelDeployRequestData>>): UseMutationOptions<CancelDeployRequestResponse, DefaultError, Options<CancelDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<CancelDeployRequestResponse, DefaultError, Options<CancelDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await cancelDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete an errored deploy
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const completeErroredDeployMutation = (options?: Partial<Options<CompleteErroredDeployData>>): UseMutationOptions<CompleteErroredDeployResponse, DefaultError, Options<CompleteErroredDeployData>> => {
    const mutationOptions: UseMutationOptions<CompleteErroredDeployResponse, DefaultError, Options<CompleteErroredDeployData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await completeErroredDeploy({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Queue a deploy request
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const queueDeployRequestMutation = (options?: Partial<Options<QueueDeployRequestData>>): UseMutationOptions<QueueDeployRequestResponse, DefaultError, Options<QueueDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<QueueDeployRequestResponse, DefaultError, Options<QueueDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await queueDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeploymentQueryKey = (options: Options<GetDeploymentData>) => createQueryKey('getDeployment', options);

/**
 * Get a deployment
 *
 * Get the deployment for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const getDeploymentOptions = (options: Options<GetDeploymentData>) => queryOptions<GetDeploymentResponse, DefaultError, GetDeploymentResponse, ReturnType<typeof getDeploymentQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployment({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeploymentQueryKey(options)
});

export const listDeployOperationsQueryKey = (options: Options<ListDeployOperationsData>) => createQueryKey('listDeployOperations', options);

/**
 * List deploy operations
 *
 * List deploy operations for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const listDeployOperationsOptions = (options: Options<ListDeployOperationsData>) => queryOptions<ListDeployOperationsResponse, DefaultError, ListDeployOperationsResponse, ReturnType<typeof listDeployOperationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDeployOperations({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDeployOperationsQueryKey(options)
});

export const listDeployOperationsInfiniteQueryKey = (options: Options<ListDeployOperationsData>): QueryKey<Options<ListDeployOperationsData>> => createQueryKey('listDeployOperations', options, true);

/**
 * List deploy operations
 *
 * List deploy operations for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const listDeployOperationsInfiniteOptions = (options: Options<ListDeployOperationsData>) => infiniteQueryOptions<ListDeployOperationsResponse, DefaultError, InfiniteData<ListDeployOperationsResponse>, QueryKey<Options<ListDeployOperationsData>>, number | Pick<QueryKey<Options<ListDeployOperationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDeployOperationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDeployOperations({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDeployOperationsInfiniteQueryKey(options)
});

/**
 * Complete a revert
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const completeRevertMutation = (options?: Partial<Options<CompleteRevertData>>): UseMutationOptions<CompleteRevertResponse, DefaultError, Options<CompleteRevertData>> => {
    const mutationOptions: UseMutationOptions<CompleteRevertResponse, DefaultError, Options<CompleteRevertData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await completeRevert({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listDeployRequestReviewsQueryKey = (options: Options<ListDeployRequestReviewsData>) => createQueryKey('listDeployRequestReviews', options);

/**
 * List deploy request reviews
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const listDeployRequestReviewsOptions = (options: Options<ListDeployRequestReviewsData>) => queryOptions<ListDeployRequestReviewsResponse, DefaultError, ListDeployRequestReviewsResponse, ReturnType<typeof listDeployRequestReviewsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDeployRequestReviews({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDeployRequestReviewsQueryKey(options)
});

/**
 * Review a deploy request
 *
 * Review a deploy request by either approving or commenting on the deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `approve_deploy_request`, `review_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `approve_deploy_requests` |
 * | Database | `approve_deploy_requests` |
 */
export const reviewDeployRequestMutation = (options?: Partial<Options<ReviewDeployRequestData>>): UseMutationOptions<ReviewDeployRequestResponse, DefaultError, Options<ReviewDeployRequestData>> => {
    const mutationOptions: UseMutationOptions<ReviewDeployRequestResponse, DefaultError, Options<ReviewDeployRequestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await reviewDeployRequest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Skip revert period
 *
 * Skips the revert period for a deploy request
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const skipRevertPeriodMutation = (options?: Partial<Options<SkipRevertPeriodData>>): UseMutationOptions<SkipRevertPeriodResponse, DefaultError, Options<SkipRevertPeriodData>> => {
    const mutationOptions: UseMutationOptions<SkipRevertPeriodResponse, DefaultError, Options<SkipRevertPeriodData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await skipRevertPeriod({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDeployRequestThrottlerQueryKey = (options: Options<GetDeployRequestThrottlerData>) => createQueryKey('getDeployRequestThrottler', options);

/**
 * Get deploy request throttler configurations
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_deploy_requests` |
 * | Database | `read_deploy_requests` |
 */
export const getDeployRequestThrottlerOptions = (options: Options<GetDeployRequestThrottlerData>) => queryOptions<GetDeployRequestThrottlerResponse, DefaultError, GetDeployRequestThrottlerResponse, ReturnType<typeof getDeployRequestThrottlerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDeployRequestThrottler({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDeployRequestThrottlerQueryKey(options)
});

/**
 * Update deploy request throttler configurations
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const updateDeployRequestThrottlerMutation = (options?: Partial<Options<UpdateDeployRequestThrottlerData>>): UseMutationOptions<UpdateDeployRequestThrottlerResponse, DefaultError, Options<UpdateDeployRequestThrottlerData>> => {
    const mutationOptions: UseMutationOptions<UpdateDeployRequestThrottlerResponse, DefaultError, Options<UpdateDeployRequestThrottlerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDeployRequestThrottler({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listReadOnlyRegionsQueryKey = (options: Options<ListReadOnlyRegionsData>) => createQueryKey('listReadOnlyRegions', options);

/**
 * List read-only regions
 *
 * List read-only regions for the database's default branch
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 */
export const listReadOnlyRegionsOptions = (options: Options<ListReadOnlyRegionsData>) => queryOptions<ListReadOnlyRegionsResponse, DefaultError, ListReadOnlyRegionsResponse, ReturnType<typeof listReadOnlyRegionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listReadOnlyRegions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listReadOnlyRegionsQueryKey(options)
});

export const listReadOnlyRegionsInfiniteQueryKey = (options: Options<ListReadOnlyRegionsData>): QueryKey<Options<ListReadOnlyRegionsData>> => createQueryKey('listReadOnlyRegions', options, true);

/**
 * List read-only regions
 *
 * List read-only regions for the database's default branch
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_branches` |
 * | Database | `read_branches` |
 */
export const listReadOnlyRegionsInfiniteOptions = (options: Options<ListReadOnlyRegionsData>) => infiniteQueryOptions<ListReadOnlyRegionsResponse, DefaultError, InfiniteData<ListReadOnlyRegionsResponse>, QueryKey<Options<ListReadOnlyRegionsData>>, number | Pick<QueryKey<Options<ListReadOnlyRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListReadOnlyRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listReadOnlyRegions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listReadOnlyRegionsInfiniteQueryKey(options)
});

export const listDatabaseRegionsQueryKey = (options: Options<ListDatabaseRegionsData>) => createQueryKey('listDatabaseRegions', options);

/**
 * List database regions
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listDatabaseRegionsOptions = (options: Options<ListDatabaseRegionsData>) => queryOptions<ListDatabaseRegionsResponse, DefaultError, ListDatabaseRegionsResponse, ReturnType<typeof listDatabaseRegionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listDatabaseRegions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabaseRegionsQueryKey(options)
});

export const listDatabaseRegionsInfiniteQueryKey = (options: Options<ListDatabaseRegionsData>): QueryKey<Options<ListDatabaseRegionsData>> => createQueryKey('listDatabaseRegions', options, true);

/**
 * List database regions
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`, `delete_database`, `write_database`, `read_branch`, `delete_branch`, `create_branch`, `delete_production_branch`, `connect_branch`, `connect_production_branch`, `delete_branch_password`, `delete_production_branch_password`, `read_deploy_request`, `create_deploy_request`, `approve_deploy_request`, `read_comment`, `create_comment`, `restore_backup`, `restore_production_branch_backup`, `read_backups`, `write_backups`, `delete_backups`, `delete_production_branch_backups`, `write_branch_vschema`, `write_production_branch_vschema`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listDatabaseRegionsInfiniteOptions = (options: Options<ListDatabaseRegionsData>) => infiniteQueryOptions<ListDatabaseRegionsResponse, DefaultError, InfiniteData<ListDatabaseRegionsResponse>, QueryKey<Options<ListDatabaseRegionsData>>, number | Pick<QueryKey<Options<ListDatabaseRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListDatabaseRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listDatabaseRegions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listDatabaseRegionsInfiniteQueryKey(options)
});

export const getDatabaseThrottlerQueryKey = (options: Options<GetDatabaseThrottlerData>) => createQueryKey('getDatabaseThrottler', options);

/**
 * Get database throttler configurations
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const getDatabaseThrottlerOptions = (options: Options<GetDatabaseThrottlerData>) => queryOptions<GetDatabaseThrottlerResponse, DefaultError, GetDatabaseThrottlerResponse, ReturnType<typeof getDatabaseThrottlerQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDatabaseThrottler({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDatabaseThrottlerQueryKey(options)
});

/**
 * Update database throttler configurations
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_deploy_request`, `create_deploy_request`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `deploy_deploy_requests` |
 * | Database | `deploy_deploy_requests` |
 */
export const updateDatabaseThrottlerMutation = (options?: Partial<Options<UpdateDatabaseThrottlerData>>): UseMutationOptions<UpdateDatabaseThrottlerResponse, DefaultError, Options<UpdateDatabaseThrottlerData>> => {
    const mutationOptions: UseMutationOptions<UpdateDatabaseThrottlerResponse, DefaultError, Options<UpdateDatabaseThrottlerData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateDatabaseThrottler({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWebhooksQueryKey = (options: Options<ListWebhooksData>) => createQueryKey('listWebhooks', options);

/**
 * List webhooks
 *
 * List webhooks for a database
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listWebhooksOptions = (options: Options<ListWebhooksData>) => queryOptions<ListWebhooksResponse, DefaultError, ListWebhooksResponse, ReturnType<typeof listWebhooksQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listWebhooks({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWebhooksQueryKey(options)
});

export const listWebhooksInfiniteQueryKey = (options: Options<ListWebhooksData>): QueryKey<Options<ListWebhooksData>> => createQueryKey('listWebhooks', options, true);

/**
 * List webhooks
 *
 * List webhooks for a database
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const listWebhooksInfiniteOptions = (options: Options<ListWebhooksData>) => infiniteQueryOptions<ListWebhooksResponse, DefaultError, InfiniteData<ListWebhooksResponse>, QueryKey<Options<ListWebhooksData>>, number | Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListWebhooksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWebhooks({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWebhooksInfiniteQueryKey(options)
});

/**
 * Create a webhook
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const createWebhookMutation = (options?: Partial<Options<CreateWebhookData>>): UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> => {
    const mutationOptions: UseMutationOptions<CreateWebhookResponse, DefaultError, Options<CreateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a webhook
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const deleteWebhookMutation = (options?: Partial<Options<DeleteWebhookData>>): UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> => {
    const mutationOptions: UseMutationOptions<DeleteWebhookResponse, DefaultError, Options<DeleteWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWebhookQueryKey = (options: Options<GetWebhookData>) => createQueryKey('getWebhook', options);

/**
 * Get a webhook
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_databases` |
 * | Database | `read_database` |
 */
export const getWebhookOptions = (options: Options<GetWebhookData>) => queryOptions<GetWebhookResponse, DefaultError, GetWebhookResponse, ReturnType<typeof getWebhookQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWebhook({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWebhookQueryKey(options)
});

/**
 * Update a webhook
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const updateWebhookMutation = (options?: Partial<Options<UpdateWebhookData>>): UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> => {
    const mutationOptions: UseMutationOptions<UpdateWebhookResponse, DefaultError, Options<UpdateWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test a webhook
 *
 * Sends a test event to the webhook
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_database`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_databases` |
 * | Database | `write_database` |
 */
export const testWebhookMutation = (options?: Partial<Options<TestWebhookData>>): UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> => {
    const mutationOptions: UseMutationOptions<TestWebhookResponse, DefaultError, Options<TestWebhookData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await testWebhook({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listWorkflowsQueryKey = (options: Options<ListWorkflowsData>) => createQueryKey('listWorkflows', options);

/**
 * List workflows
 *
 *
 *
 */
export const listWorkflowsOptions = (options: Options<ListWorkflowsData>) => queryOptions<ListWorkflowsResponse, DefaultError, ListWorkflowsResponse, ReturnType<typeof listWorkflowsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listWorkflows({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowsQueryKey(options)
});

export const listWorkflowsInfiniteQueryKey = (options: Options<ListWorkflowsData>): QueryKey<Options<ListWorkflowsData>> => createQueryKey('listWorkflows', options, true);

/**
 * List workflows
 *
 *
 *
 */
export const listWorkflowsInfiniteOptions = (options: Options<ListWorkflowsData>) => infiniteQueryOptions<ListWorkflowsResponse, DefaultError, InfiniteData<ListWorkflowsResponse>, QueryKey<Options<ListWorkflowsData>>, number | Pick<QueryKey<Options<ListWorkflowsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListWorkflowsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listWorkflows({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listWorkflowsInfiniteQueryKey(options)
});

/**
 * Create a workflow
 *
 *
 *
 */
export const createWorkflowMutation = (options?: Partial<Options<CreateWorkflowData>>): UseMutationOptions<CreateWorkflowResponse, DefaultError, Options<CreateWorkflowData>> => {
    const mutationOptions: UseMutationOptions<CreateWorkflowResponse, DefaultError, Options<CreateWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel a workflow
 *
 *
 *
 */
export const workflowCancelMutation = (options?: Partial<Options<WorkflowCancelData>>): UseMutationOptions<WorkflowCancelResponse, DefaultError, Options<WorkflowCancelData>> => {
    const mutationOptions: UseMutationOptions<WorkflowCancelResponse, DefaultError, Options<WorkflowCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getWorkflowQueryKey = (options: Options<GetWorkflowData>) => createQueryKey('getWorkflow', options);

/**
 * Get a workflow
 *
 *
 *
 */
export const getWorkflowOptions = (options: Options<GetWorkflowData>) => queryOptions<GetWorkflowResponse, DefaultError, GetWorkflowResponse, ReturnType<typeof getWorkflowQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getWorkflow({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getWorkflowQueryKey(options)
});

/**
 * Complete a workflow
 *
 *
 *
 */
export const workflowCompleteMutation = (options?: Partial<Options<WorkflowCompleteData>>): UseMutationOptions<WorkflowCompleteResponse, DefaultError, Options<WorkflowCompleteData>> => {
    const mutationOptions: UseMutationOptions<WorkflowCompleteResponse, DefaultError, Options<WorkflowCompleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowComplete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cutover traffic
 *
 *
 *
 */
export const workflowCutoverMutation = (options?: Partial<Options<WorkflowCutoverData>>): UseMutationOptions<WorkflowCutoverResponse, DefaultError, Options<WorkflowCutoverData>> => {
    const mutationOptions: UseMutationOptions<WorkflowCutoverResponse, DefaultError, Options<WorkflowCutoverData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowCutover({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Retry a failed workflow
 *
 *
 *
 */
export const workflowRetryMutation = (options?: Partial<Options<WorkflowRetryData>>): UseMutationOptions<WorkflowRetryResponse, DefaultError, Options<WorkflowRetryData>> => {
    const mutationOptions: UseMutationOptions<WorkflowRetryResponse, DefaultError, Options<WorkflowRetryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowRetry({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reverse traffic cutover
 *
 *
 *
 */
export const workflowReverseCutoverMutation = (options?: Partial<Options<WorkflowReverseCutoverData>>): UseMutationOptions<WorkflowReverseCutoverResponse, DefaultError, Options<WorkflowReverseCutoverData>> => {
    const mutationOptions: UseMutationOptions<WorkflowReverseCutoverResponse, DefaultError, Options<WorkflowReverseCutoverData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowReverseCutover({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reverse traffic
 *
 *
 *
 */
export const workflowReverseTrafficMutation = (options?: Partial<Options<WorkflowReverseTrafficData>>): UseMutationOptions<WorkflowReverseTrafficResponse, DefaultError, Options<WorkflowReverseTrafficData>> => {
    const mutationOptions: UseMutationOptions<WorkflowReverseTrafficResponse, DefaultError, Options<WorkflowReverseTrafficData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowReverseTraffic({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Switch primary traffic
 *
 *
 *
 */
export const workflowSwitchPrimariesMutation = (options?: Partial<Options<WorkflowSwitchPrimariesData>>): UseMutationOptions<WorkflowSwitchPrimariesResponse, DefaultError, Options<WorkflowSwitchPrimariesData>> => {
    const mutationOptions: UseMutationOptions<WorkflowSwitchPrimariesResponse, DefaultError, Options<WorkflowSwitchPrimariesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowSwitchPrimaries({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Switch replica traffic
 *
 *
 *
 */
export const workflowSwitchReplicasMutation = (options?: Partial<Options<WorkflowSwitchReplicasData>>): UseMutationOptions<WorkflowSwitchReplicasResponse, DefaultError, Options<WorkflowSwitchReplicasData>> => {
    const mutationOptions: UseMutationOptions<WorkflowSwitchReplicasResponse, DefaultError, Options<WorkflowSwitchReplicasData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await workflowSwitchReplicas({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Verify workflow data
 *
 *
 *
 */
export const verifyWorkflowMutation = (options?: Partial<Options<VerifyWorkflowData>>): UseMutationOptions<VerifyWorkflowResponse, DefaultError, Options<VerifyWorkflowData>> => {
    const mutationOptions: UseMutationOptions<VerifyWorkflowResponse, DefaultError, Options<VerifyWorkflowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await verifyWorkflow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listInvoicesQueryKey = (options: Options<ListInvoicesData>) => createQueryKey('listInvoices', options);

/**
 * Get invoices
 *
 * Get the invoices for an organization
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_invoices`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_invoices` |
 */
export const listInvoicesOptions = (options: Options<ListInvoicesData>) => queryOptions<ListInvoicesResponse, DefaultError, ListInvoicesResponse, ReturnType<typeof listInvoicesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listInvoices({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listInvoicesQueryKey(options)
});

export const listInvoicesInfiniteQueryKey = (options: Options<ListInvoicesData>): QueryKey<Options<ListInvoicesData>> => createQueryKey('listInvoices', options, true);

/**
 * Get invoices
 *
 * Get the invoices for an organization
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_invoices`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_invoices` |
 */
export const listInvoicesInfiniteOptions = (options: Options<ListInvoicesData>) => infiniteQueryOptions<ListInvoicesResponse, DefaultError, InfiniteData<ListInvoicesResponse>, QueryKey<Options<ListInvoicesData>>, number | Pick<QueryKey<Options<ListInvoicesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListInvoicesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listInvoices({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listInvoicesInfiniteQueryKey(options)
});

export const getInvoiceQueryKey = (options: Options<GetInvoiceData>) => createQueryKey('getInvoice', options);

/**
 * Get an invoice
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_invoices`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_invoices` |
 */
export const getInvoiceOptions = (options: Options<GetInvoiceData>) => queryOptions<GetInvoiceResponse, DefaultError, GetInvoiceResponse, ReturnType<typeof getInvoiceQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getInvoice({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getInvoiceQueryKey(options)
});

export const getInvoiceLineItemsQueryKey = (options: Options<GetInvoiceLineItemsData>) => createQueryKey('getInvoiceLineItems', options);

/**
 * Get invoice line items
 *
 * Get the line items for an invoice
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_invoices`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_invoices` |
 */
export const getInvoiceLineItemsOptions = (options: Options<GetInvoiceLineItemsData>) => queryOptions<GetInvoiceLineItemsResponse, DefaultError, GetInvoiceLineItemsResponse, ReturnType<typeof getInvoiceLineItemsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getInvoiceLineItems({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getInvoiceLineItemsQueryKey(options)
});

export const getInvoiceLineItemsInfiniteQueryKey = (options: Options<GetInvoiceLineItemsData>): QueryKey<Options<GetInvoiceLineItemsData>> => createQueryKey('getInvoiceLineItems', options, true);

/**
 * Get invoice line items
 *
 * Get the line items for an invoice
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_invoices`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_invoices` |
 */
export const getInvoiceLineItemsInfiniteOptions = (options: Options<GetInvoiceLineItemsData>) => infiniteQueryOptions<GetInvoiceLineItemsResponse, DefaultError, InfiniteData<GetInvoiceLineItemsResponse>, QueryKey<Options<GetInvoiceLineItemsData>>, number | Pick<QueryKey<Options<GetInvoiceLineItemsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GetInvoiceLineItemsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await getInvoiceLineItems({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getInvoiceLineItemsInfiniteQueryKey(options)
});

export const listOrganizationMembersQueryKey = (options: Options<ListOrganizationMembersData>) => createQueryKey('listOrganizationMembers', options);

/**
 * List organization members
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const listOrganizationMembersOptions = (options: Options<ListOrganizationMembersData>) => queryOptions<ListOrganizationMembersResponse, DefaultError, ListOrganizationMembersResponse, ReturnType<typeof listOrganizationMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOrganizationMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationMembersQueryKey(options)
});

export const listOrganizationMembersInfiniteQueryKey = (options: Options<ListOrganizationMembersData>): QueryKey<Options<ListOrganizationMembersData>> => createQueryKey('listOrganizationMembers', options, true);

/**
 * List organization members
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const listOrganizationMembersInfiniteOptions = (options: Options<ListOrganizationMembersData>) => infiniteQueryOptions<ListOrganizationMembersResponse, DefaultError, InfiniteData<ListOrganizationMembersResponse>, QueryKey<Options<ListOrganizationMembersData>>, number | Pick<QueryKey<Options<ListOrganizationMembersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListOrganizationMembersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listOrganizationMembers({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationMembersInfiniteQueryKey(options)
});

/**
 * Remove a member from an organization
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const removeOrganizationMemberMutation = (options?: Partial<Options<RemoveOrganizationMemberData>>): UseMutationOptions<RemoveOrganizationMemberResponse, DefaultError, Options<RemoveOrganizationMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveOrganizationMemberResponse, DefaultError, Options<RemoveOrganizationMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeOrganizationMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationMembershipQueryKey = (options: Options<GetOrganizationMembershipData>) => createQueryKey('getOrganizationMembership', options);

/**
 * Get an organization member
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const getOrganizationMembershipOptions = (options: Options<GetOrganizationMembershipData>) => queryOptions<GetOrganizationMembershipResponse, DefaultError, GetOrganizationMembershipResponse, ReturnType<typeof getOrganizationMembershipQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOrganizationMembership({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOrganizationMembershipQueryKey(options)
});

/**
 * Update organization member role
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const updateOrganizationMembershipMutation = (options?: Partial<Options<UpdateOrganizationMembershipData>>): UseMutationOptions<UpdateOrganizationMembershipResponse, DefaultError, Options<UpdateOrganizationMembershipData>> => {
    const mutationOptions: UseMutationOptions<UpdateOrganizationMembershipResponse, DefaultError, Options<UpdateOrganizationMembershipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOrganizationMembership({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listOauthApplicationsQueryKey = (options: Options<ListOauthApplicationsData>) => createQueryKey('listOauthApplications', options);

/**
 * List OAuth applications
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_applications`
 *
 *
 */
export const listOauthApplicationsOptions = (options: Options<ListOauthApplicationsData>) => queryOptions<ListOauthApplicationsResponse, DefaultError, ListOauthApplicationsResponse, ReturnType<typeof listOauthApplicationsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOauthApplications({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOauthApplicationsQueryKey(options)
});

export const listOauthApplicationsInfiniteQueryKey = (options: Options<ListOauthApplicationsData>): QueryKey<Options<ListOauthApplicationsData>> => createQueryKey('listOauthApplications', options, true);

/**
 * List OAuth applications
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_applications`
 *
 *
 */
export const listOauthApplicationsInfiniteOptions = (options: Options<ListOauthApplicationsData>) => infiniteQueryOptions<ListOauthApplicationsResponse, DefaultError, InfiniteData<ListOauthApplicationsResponse>, QueryKey<Options<ListOauthApplicationsData>>, number | Pick<QueryKey<Options<ListOauthApplicationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListOauthApplicationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listOauthApplications({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOauthApplicationsInfiniteQueryKey(options)
});

export const getOauthApplicationQueryKey = (options: Options<GetOauthApplicationData>) => createQueryKey('getOauthApplication', options);

/**
 * Get an OAuth application
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_applications`
 *
 *
 */
export const getOauthApplicationOptions = (options: Options<GetOauthApplicationData>) => queryOptions<GetOauthApplicationResponse, DefaultError, GetOauthApplicationResponse, ReturnType<typeof getOauthApplicationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOauthApplication({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOauthApplicationQueryKey(options)
});

export const listOauthTokensQueryKey = (options: Options<ListOauthTokensData>) => createQueryKey('listOauthTokens', options);

/**
 * List OAuth tokens
 *
 * List OAuth tokens created by an OAuth application
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_tokens`
 *
 *
 */
export const listOauthTokensOptions = (options: Options<ListOauthTokensData>) => queryOptions<ListOauthTokensResponse, DefaultError, ListOauthTokensResponse, ReturnType<typeof listOauthTokensQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOauthTokens({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOauthTokensQueryKey(options)
});

export const listOauthTokensInfiniteQueryKey = (options: Options<ListOauthTokensData>): QueryKey<Options<ListOauthTokensData>> => createQueryKey('listOauthTokens', options, true);

/**
 * List OAuth tokens
 *
 * List OAuth tokens created by an OAuth application
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_tokens`
 *
 *
 */
export const listOauthTokensInfiniteOptions = (options: Options<ListOauthTokensData>) => infiniteQueryOptions<ListOauthTokensResponse, DefaultError, InfiniteData<ListOauthTokensResponse>, QueryKey<Options<ListOauthTokensData>>, number | Pick<QueryKey<Options<ListOauthTokensData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListOauthTokensData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listOauthTokens({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOauthTokensInfiniteQueryKey(options)
});

/**
 * Delete an OAuth token
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_oauth_tokens`
 *
 *
 */
export const deleteOauthTokenMutation = (options?: Partial<Options<DeleteOauthTokenData>>): UseMutationOptions<DeleteOauthTokenResponse, DefaultError, Options<DeleteOauthTokenData>> => {
    const mutationOptions: UseMutationOptions<DeleteOauthTokenResponse, DefaultError, Options<DeleteOauthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteOauthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOauthTokenQueryKey = (options: Options<GetOauthTokenData>) => createQueryKey('getOauthToken', options);

/**
 * Get an OAuth token
 *
 *
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_oauth_tokens`
 *
 *
 */
export const getOauthTokenOptions = (options: Options<GetOauthTokenData>) => queryOptions<GetOauthTokenResponse, DefaultError, GetOauthTokenResponse, ReturnType<typeof getOauthTokenQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOauthToken({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOauthTokenQueryKey(options)
});

/**
 * Create or renew an OAuth token
 *
 * Create an OAuth token from an authorization grant code, or refresh an OAuth token from a refresh token
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_oauth_tokens`
 *
 *
 */
export const createOauthTokenMutation = (options?: Partial<Options<CreateOauthTokenData>>): UseMutationOptions<CreateOauthTokenResponse, DefaultError, Options<CreateOauthTokenData>> => {
    const mutationOptions: UseMutationOptions<CreateOauthTokenResponse, DefaultError, Options<CreateOauthTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOauthToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listRegionsForOrganizationQueryKey = (options: Options<ListRegionsForOrganizationData>) => createQueryKey('listRegionsForOrganization', options);

/**
 * List regions for an organization
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 * | Organization | `read_organization` |
 */
export const listRegionsForOrganizationOptions = (options: Options<ListRegionsForOrganizationData>) => queryOptions<ListRegionsForOrganizationResponse, DefaultError, ListRegionsForOrganizationResponse, ReturnType<typeof listRegionsForOrganizationQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listRegionsForOrganization({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRegionsForOrganizationQueryKey(options)
});

export const listRegionsForOrganizationInfiniteQueryKey = (options: Options<ListRegionsForOrganizationData>): QueryKey<Options<ListRegionsForOrganizationData>> => createQueryKey('listRegionsForOrganization', options, true);

/**
 * List regions for an organization
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_organizations` |
 * | Organization | `read_organization` |
 */
export const listRegionsForOrganizationInfiniteOptions = (options: Options<ListRegionsForOrganizationData>) => infiniteQueryOptions<ListRegionsForOrganizationResponse, DefaultError, InfiniteData<ListRegionsForOrganizationResponse>, QueryKey<Options<ListRegionsForOrganizationData>>, number | Pick<QueryKey<Options<ListRegionsForOrganizationData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListRegionsForOrganizationData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listRegionsForOrganization({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listRegionsForOrganizationInfiniteQueryKey(options)
});

export const listServiceTokensQueryKey = (options: Options<ListServiceTokensData>) => createQueryKey('listServiceTokens', options);

/**
 * List service tokens
 *
 * List service tokens for an organization.
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_service_tokens`
 *
 *
 */
export const listServiceTokensOptions = (options: Options<ListServiceTokensData>) => queryOptions<ListServiceTokensResponse, DefaultError, ListServiceTokensResponse, ReturnType<typeof listServiceTokensQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listServiceTokens({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServiceTokensQueryKey(options)
});

export const listServiceTokensInfiniteQueryKey = (options: Options<ListServiceTokensData>): QueryKey<Options<ListServiceTokensData>> => createQueryKey('listServiceTokens', options, true);

/**
 * List service tokens
 *
 * List service tokens for an organization.
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_service_tokens`
 *
 *
 */
export const listServiceTokensInfiniteOptions = (options: Options<ListServiceTokensData>) => infiniteQueryOptions<ListServiceTokensResponse, DefaultError, InfiniteData<ListServiceTokensResponse>, QueryKey<Options<ListServiceTokensData>>, number | Pick<QueryKey<Options<ListServiceTokensData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListServiceTokensData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listServiceTokens({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listServiceTokensInfiniteQueryKey(options)
});

/**
 * Create a service token
 *
 * Create a new service token for the organization.
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_service_tokens`
 *
 *
 */
export const createServiceTokenMutation = (options?: Partial<Options<CreateServiceTokenData>>): UseMutationOptions<CreateServiceTokenResponse, DefaultError, Options<CreateServiceTokenData>> => {
    const mutationOptions: UseMutationOptions<CreateServiceTokenResponse, DefaultError, Options<CreateServiceTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createServiceToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a service token
 *
 * Delete a service token from the organization.
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `delete_service_tokens`
 *
 *
 */
export const deleteServiceTokenMutation = (options?: Partial<Options<DeleteServiceTokenData>>): UseMutationOptions<DeleteServiceTokenResponse, DefaultError, Options<DeleteServiceTokenData>> => {
    const mutationOptions: UseMutationOptions<DeleteServiceTokenResponse, DefaultError, Options<DeleteServiceTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteServiceToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getServiceTokenQueryKey = (options: Options<GetServiceTokenData>) => createQueryKey('getServiceToken', options);

/**
 * Get a service token
 *
 * Get information about a service token.
 * ### Authorization
 * A service token   must have at least one of the following access   in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_service_tokens`
 *
 *
 */
export const getServiceTokenOptions = (options: Options<GetServiceTokenData>) => queryOptions<GetServiceTokenResponse, DefaultError, GetServiceTokenResponse, ReturnType<typeof getServiceTokenQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getServiceToken({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getServiceTokenQueryKey(options)
});

export const listOrganizationTeamsQueryKey = (options: Options<ListOrganizationTeamsData>) => createQueryKey('listOrganizationTeams', options);

/**
 * List teams in an organization
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const listOrganizationTeamsOptions = (options: Options<ListOrganizationTeamsData>) => queryOptions<ListOrganizationTeamsResponse, DefaultError, ListOrganizationTeamsResponse, ReturnType<typeof listOrganizationTeamsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOrganizationTeams({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationTeamsQueryKey(options)
});

/**
 * Create an organization team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_teams`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const createOrganizationTeamMutation = (options?: Partial<Options<CreateOrganizationTeamData>>): UseMutationOptions<CreateOrganizationTeamResponse, DefaultError, Options<CreateOrganizationTeamData>> => {
    const mutationOptions: UseMutationOptions<CreateOrganizationTeamResponse, DefaultError, Options<CreateOrganizationTeamData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createOrganizationTeam({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an organization team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_teams`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const deleteOrganizationTeamMutation = (options?: Partial<Options<DeleteOrganizationTeamData>>): UseMutationOptions<DeleteOrganizationTeamResponse, DefaultError, Options<DeleteOrganizationTeamData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationTeamResponse, DefaultError, Options<DeleteOrganizationTeamData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteOrganizationTeam({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationTeamQueryKey = (options: Options<GetOrganizationTeamData>) => createQueryKey('getOrganizationTeam', options);

/**
 * Get an organization team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const getOrganizationTeamOptions = (options: Options<GetOrganizationTeamData>) => queryOptions<GetOrganizationTeamResponse, DefaultError, GetOrganizationTeamResponse, ReturnType<typeof getOrganizationTeamQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOrganizationTeam({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOrganizationTeamQueryKey(options)
});

/**
 * Update an organization team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_teams`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const updateOrganizationTeamMutation = (options?: Partial<Options<UpdateOrganizationTeamData>>): UseMutationOptions<UpdateOrganizationTeamResponse, DefaultError, Options<UpdateOrganizationTeamData>> => {
    const mutationOptions: UseMutationOptions<UpdateOrganizationTeamResponse, DefaultError, Options<UpdateOrganizationTeamData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateOrganizationTeam({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listOrganizationTeamMembersQueryKey = (options: Options<ListOrganizationTeamMembersData>) => createQueryKey('listOrganizationTeamMembers', options);

/**
 * List team members
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const listOrganizationTeamMembersOptions = (options: Options<ListOrganizationTeamMembersData>) => queryOptions<ListOrganizationTeamMembersResponse, DefaultError, ListOrganizationTeamMembersResponse, ReturnType<typeof listOrganizationTeamMembersQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listOrganizationTeamMembers({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listOrganizationTeamMembersQueryKey(options)
});

/**
 * Add a member to a team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_teams`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const addOrganizationTeamMemberMutation = (options?: Partial<Options<AddOrganizationTeamMemberData>>): UseMutationOptions<AddOrganizationTeamMemberResponse, DefaultError, Options<AddOrganizationTeamMemberData>> => {
    const mutationOptions: UseMutationOptions<AddOrganizationTeamMemberResponse, DefaultError, Options<AddOrganizationTeamMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await addOrganizationTeamMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a member from a team
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `write_teams`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `write_organization` |
 */
export const removeOrganizationTeamMemberMutation = (options?: Partial<Options<RemoveOrganizationTeamMemberData>>): UseMutationOptions<RemoveOrganizationTeamMemberResponse, DefaultError, Options<RemoveOrganizationTeamMemberData>> => {
    const mutationOptions: UseMutationOptions<RemoveOrganizationTeamMemberResponse, DefaultError, Options<RemoveOrganizationTeamMemberData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await removeOrganizationTeamMember({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationTeamMemberQueryKey = (options: Options<GetOrganizationTeamMemberData>) => createQueryKey('getOrganizationTeamMember', options);

/**
 * Get a team member
 *
 *
 * ### Authorization
 * A service token or OAuth token must have at least one of the following access or scopes in order to use this API endpoint:
 *
 * **Service Token Accesses**
 * `read_organization`
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | Organization | `read_organization` |
 */
export const getOrganizationTeamMemberOptions = (options: Options<GetOrganizationTeamMemberData>) => queryOptions<GetOrganizationTeamMemberResponse, DefaultError, GetOrganizationTeamMemberResponse, ReturnType<typeof getOrganizationTeamMemberQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOrganizationTeamMember({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOrganizationTeamMemberQueryKey(options)
});

export const listPublicRegionsQueryKey = (options?: Options<ListPublicRegionsData>) => createQueryKey('listPublicRegions', options);

/**
 * List public regions
 *
 * Endpoint is available without authentication.
 *
 */
export const listPublicRegionsOptions = (options?: Options<ListPublicRegionsData>) => queryOptions<ListPublicRegionsResponse, DefaultError, ListPublicRegionsResponse, ReturnType<typeof listPublicRegionsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPublicRegions({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPublicRegionsQueryKey(options)
});

export const listPublicRegionsInfiniteQueryKey = (options?: Options<ListPublicRegionsData>): QueryKey<Options<ListPublicRegionsData>> => createQueryKey('listPublicRegions', options, true);

/**
 * List public regions
 *
 * Endpoint is available without authentication.
 *
 */
export const listPublicRegionsInfiniteOptions = (options?: Options<ListPublicRegionsData>) => infiniteQueryOptions<ListPublicRegionsResponse, DefaultError, InfiniteData<ListPublicRegionsResponse>, QueryKey<Options<ListPublicRegionsData>>, number | Pick<QueryKey<Options<ListPublicRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListPublicRegionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listPublicRegions({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPublicRegionsInfiniteQueryKey(options)
});

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) => createQueryKey('getCurrentUser', options);

/**
 * Get current user
 *
 * Get the user associated with this service token
 * ### Authorization
 * A   OAuth token must have at least one of the following   scopes in order to use this API endpoint:
 *
 * **OAuth Scopes**
 *
 * | Resource | Scopes |
 * | :------- | :---------- |
 * | User | `read_user` |
 */
export const getCurrentUserOptions = (options?: Options<GetCurrentUserData>) => queryOptions<GetCurrentUserResponse, DefaultError, GetCurrentUserResponse, ReturnType<typeof getCurrentUserQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCurrentUser({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCurrentUserQueryKey(options)
});
